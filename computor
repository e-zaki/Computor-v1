#!/usr/bin/env python3
import re
import sys
from fractions import Fraction

def validate_chars(equation):
    """Reject any character not part of valid polynomial syntax."""
    allowed_chars = r'[\dXx \+\-\*\.\^=]'
    if not re.fullmatch(f'^{allowed_chars}+$', equation):
        illegal_chars = set(re.findall(f'[^{allowed_chars}]', equation))
        raise ValueError(f"Illegal character(s): {', '.join(map(repr, illegal_chars))}")

def validate_equation_structure(equation):
    """Check for structural errors (e.g., multiple '=', dangling operators)."""
    if equation.count('=') != 1:
        raise ValueError("Equation must contain exactly one '='")
    
    if re.search(r'[\+\-\*^]\s*$', equation) or re.search(r'^\s*[\+\-\*^]', equation):
        raise ValueError("Dangling operator at start/end")
    
    if re.search(r'[\+\-\*^]\s*[\+\-\*^]', equation.replace(' ', '')):
        raise ValueError("Consecutive operators")
    
    if re.search(r'X\s*\^\s*[+-]?\s*[Xx]', equation):
        raise ValueError("Invalid exponent (e.g., 'X^X')")

def parse_polynomial(term):
    """Parse terms like '4*X^2' into (power, coeff)."""
    term = term.strip().replace(' ', '')
    if not term:
        raise ValueError("Empty term")
    
    match = re.match(r'^([+-]?\d*\.?\d+)\*?[Xx](?:\^(\d+))?$|^([+-]?\d+\.?\d*)$|^[Xx](?:\^(\d+))?$', term)
    if not match:
        raise ValueError(f"Invalid term: '{term}'")
    
    coeff, power, const, x_power = match.groups()
    if const:
        return (0, float(const))
    
    coeff = float(coeff) if coeff else (1.0 if not term.startswith('-') else -1.0)
    power = int(power) if power else (int(x_power) if x_power else 1)
    return (power, coeff)

def parse_equation(equation):
    """Parse equation into coefficients with strict validation."""
    equation = equation.replace(' ', '')
    validate_chars(equation)
    validate_equation_structure(equation)
    
    left, right = equation.split('=')
    terms = re.findall(r'([+-]?\d*\.?\d*\*?[Xx](?:\^\d+)?|[\+-]?\d+\.?\d*)', left + '-' + right)
    
    coeffs = {}
    for term in terms:
        try:
            power, coeff = parse_polynomial(term)
            coeffs[power] = coeffs.get(power, 0) + coeff
        except ValueError as e:
            raise ValueError(f"Invalid term: '{term}'") from e
    
    max_power = max(coeffs.keys()) if coeffs else 0
    return [coeffs.get(p, 0) for p in range(max_power, -1, -1)]

def sqrt(n):
    """Manual square root (Babylonian method)."""
    if n < 0:
        return complex(0, (-n)**0.5)
    guess = n / 2
    for _ in range(20):
        guess = (guess + n / guess) / 2
    return guess

def solve_quadratic(a, b, c):
    """Solve axÂ² + bx + c = 0 with steps."""
    discriminant = b**2 - 4*a*c
    print(f"Discriminant: {discriminant}")
    
    if discriminant > 0:
        sqrt_disc = sqrt(discriminant)
        print(f"Square root of discriminant: {sqrt_disc}")
        root1 = (-b + sqrt_disc) / (2*a)
        root2 = (-b - sqrt_disc) / (2*a)
        return (root1, root2)
    elif discriminant == 0:
        return (-b / (2*a),)
    else:
        real = -b / (2*a)
        imag = sqrt(-discriminant) / (2*a)
        return (complex(real, imag), complex(real, -imag))

def format_fraction(num):
    """Convert float to exact fraction if possible."""
    frac = Fraction(num).limit_denominator()
    return f"{frac.numerator}/{frac.denominator}" if frac.denominator != 1 else f"{frac.numerator}"

def main():
    if len(sys.argv) != 2:
        print("Usage: ./computor \"POLYNOMIAL_EQUATION\"")
        print("Example: ./computor \"5 + 4*X + X^2 = X^2\"")
        sys.exit(1)
    
    try:
        equation = sys.argv[1]
        coeffs = parse_equation(equation)
    except ValueError as e:
        print(f"Error: {e}")
        sys.exit(1)
    
    while len(coeffs) > 1 and coeffs[0] == 0:
        coeffs.pop(0)
    
    print(f"Reduced form: {format_equation(coeffs)} = 0")
    print(f"Polynomial degree: {len(coeffs)-1}")
    
    if len(coeffs) == 1:
        print("No solution." if coeffs[0] else "Infinite solutions.")
    elif len(coeffs) == 2:
        solution = -coeffs[1] / coeffs[0]
        print(f"The solution is:\n{format_fraction(solution)} ({float(solution)})")
    elif len(coeffs) == 3:
        solutions = solve_quadratic(coeffs[0], coeffs[1], coeffs[2])
        print("Solutions:")
        for sol in solutions:
            print(f"- {format_fraction(sol.real)} ({sol.real})" if sol.imag == 0 else f"- {sol}")
    else:
        print("Degree > 2 is not supported.")

def format_equation(coeffs):
    """Format coefficients into a readable equation."""
    terms = []
    for i, coeff in enumerate(coeffs):
        power = len(coeffs) - 1 - i
        if coeff == 0:
            continue
        term = f"{coeff:+g}"
        if power >= 1:
            term += f"*X^{power}" if power > 1 else "*X"
        terms.append(term)
    equation = ' '.join(terms).replace('+', ' + ').replace('-', ' - ')
    return equation.lstrip(' +')

if __name__ == "__main__":
    main()